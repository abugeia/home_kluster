supersetNode:
  connections:
    # ✅ C'est CE champ qui configure le script wait-for-postgres
    db_host: "10.0.0.12"
    db_port: "5432"
    db_user: "superset"
    # On met un password bidon ici car on l'écrase plus bas avec le vrai secret
    db_pass: "placeholder" 
    db_name: "superset_db" 
    # Redis
    redis_host: "superset-redis-master"
    redis_port: "6379"

# ==========================================================
# 1. IMAGE & VERSION
# ==========================================================
image:
  tag: 6.0.0
  pullPolicy: IfNotPresent

# ==========================================================
# 2. INGRESS & RESEAU
# ==========================================================
ingress:
  enabled: true
  ingressClassName: traefik
  hosts:
    - superset.valab.top
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt
    gethomepage.dev/enabled: "true"
    gethomepage.dev/description: "Data Visualization"
    gethomepage.dev/group: "Data"
    gethomepage.dev/icon: "si-apachesuperset"
    gethomepage.dev/name: "Superset"
    gethomepage.dev/href: "https://superset.valab.top"
    # ⚠️ RETIRÉ : TinyAuth entrerait en conflit avec l'OIDC interne de Superset
    # traefik.ingress.kubernetes.io/router.middlewares: security-tinyauth-protect@kubernetescrd
  tls:
    - hosts:
        - superset.valab.top
      secretName: superset-tls

# ==========================================================
# 3. BASE DE DONNÉES (EXTERNE)
# ==========================================================
postgresql:
  enabled: false # On désactive car tu as ta propre DB

# ==========================================================
# 4. REDIS (CACHE + CELERY BROKER)
# ==========================================================
redis:
  enabled: true
  # ✅ Validé : Utiliser ECR est recommandé pour éviter les rate-limits Docker Hub
  image:
    registry: public.ecr.aws
    repository: bitnami/redis
    tag: 7.2.4-debian-12-r9
  auth:
    enabled: false # OK pour un homelab interne
  architecture: standalone
  master:
    persistence:
      enabled: true
      storageClass: "nfs-csi-nvme"
      size: 8Gi

# ==========================================================
# 5. WORKERS (OBLIGATOIRE POUR CLICKHOUSE/ASYNC)
# ==========================================================
# Le "beat" lance les tâches planifiées (alertes, emails, cleanup)
supersetCeleryBeat:
  enabled: true

# Le "worker" exécute les requêtes SQL lourdes en arrière-plan
supersetWorker:
  enabled: true

# ==========================================================
# 6. CONFIGURATION PYTHON & DRIVERS
# ==========================================================
configOverrides:
  secret: |
    import os
    SECRET_KEY = os.environ.get('SUPERSET_SECRET_KEY')
    
  # Configuration DB Externe & Celery
  database: |
    import os
    # Construction de l'URI Postgres avec le mot de passe injecté
    SQLALCHEMY_DATABASE_URI = f"postgresql://superset:{os.environ.get('DB_PASS')}@10.0.0.12:5432/superset_db"
    
    # Configuration Celery (Redis interne via le nom du service K8s)
    class CeleryConfig(object):
        BROKER_URL = 'redis://superset-redis-master:6379/0'
        CELERY_IMPORTS = ('superset.sql_lab', 'superset.tasks',)
        CELERY_RESULT_BACKEND = 'redis://superset-redis-master:6379/1'
    CELERY_CONFIG = CeleryConfig

    # Cache Configuration (Indispensable pour la rapidité)
    CACHE_CONFIG = {
        'CACHE_TYPE': 'RedisCache',
        'CACHE_DEFAULT_TIMEOUT': 86400,
        'CACHE_KEY_PREFIX': 'superset_results',
        'CACHE_REDIS_URL': 'redis://superset-redis-master:6379/2',
    }
    DATA_CACHE_CONFIG = CACHE_CONFIG

  # Feature Flags & Réseau
  network: |
    ENABLE_PROXY_FIX = True
    TALISMAN_ENABLED = False # Superset pense être en HTTP (derrière Traefik), donc on désactive le force-HTTPS interne
    
    # Permet d'upload des CSV/Excel pour croiser avec tes données ClickHouse
    CSV_EXTENSIONS = {"csv", "tsv", "txt"}
    EXCEL_EXTENSIONS = {"xls", "xlsx"}
    ALLOWED_EXTENSIONS = set(CSV_EXTENSIONS.union(EXCEL_EXTENSIONS))

  # Configuration OIDC (PocketID)
  enable_oauth: |
    import os
    from flask_appbuilder.security.manager import (AUTH_DB, AUTH_OAUTH)
    from flask_appbuilder.security.manager import BaseSecurityManager
    AUTH_TYPE = AUTH_OAUTH
    
    # "Admin" est OK si tu es le seul utilisateur du Homelab.
    # Sinon change pour "Gamma" (Lecture seule par défaut)
    AUTH_USER_REGISTRATION = True
    AUTH_USER_REGISTRATION_ROLE = "Admin" 
    AUTH_ROLE_ADMIN = 'Admin'
    AUTH_ROLE_PUBLIC = 'Public'

    OAUTH_PROVIDERS = [
        {
            "name": "pocketid",
            "icon": "fa-address-card",
            "token_key": "access_token",
            "remote_app": {
                "client_id": os.environ.get('POCKETID_CLIENT_ID'),
                "client_secret": os.environ.get('POCKETID_CLIENT_SECRET'),
                "server_metadata_url": "https://auth-id.valab.top/.well-known/openid-configuration",
                "client_kwargs": {"scope": "openid profile email"},
            }
        }
    ]

    # 3. LE GLUE CODE (Indispensable pour PocketID)
    # Superset refuse de créer un user s'il n'a pas username + email + first_name + last_name
    # PocketID envoie souvent juste 'name', donc on doit le découper nous-mêmes.
    class PocketIDSecurityManager(BaseSecurityManager):
        def oauth_user_info(self, provider, response=None):
            if provider == 'pocketid':
                # Récupération des infos brutes
                me = self.appbuilder.sm.oauth_remotes[provider].get('userinfo').json()
                logging.info(f"POCKETID PAYLOAD: {me}")
                
                # Découpage du nom (ex: "Antoine Dupont" -> "Antoine", "Dupont")
                # Si PocketID n'envoie pas 'name', on met "Superset User" par défaut
                full_name = me.get("name", "Superset User").split(" ")
                first_name = full_name[0]
                last_name = " ".join(full_name[1:]) if len(full_name) > 1 else "User"

                return {
                    "username": me.get("preferred_username", me.get("email")),
                    "email": me.get("email"),
                    "first_name": me.get("given_name", first_name),
                    "last_name": me.get("family_name", last_name),
                    "role_keys": me.get("groups", []),
                }
            else:
                return {}

  # On injecte notre manager personnalisé
  CUSTOM_SECURITY_MANAGER = PocketIDSecurityManager

# Script de démarrage : Installation des drivers
bootstrapScript: |
  #!/bin/bash
  
  # On suit la doc officielle avec 'uv' (le nouveau gestionnaire v6).
  # 1. .[postgres] : Installe le driver Postgres validé par l'équipe Superset
  # 2. clickhouse-connect : Pour vos données
  # 3. Authlib : Pour l'OIDC
  
  uv pip install .[postgres] clickhouse-connect Authlib

  if [ ! -f ~/bootstrap ]; then echo "Running Superset with uid {{ .Values.runAsUser }}" > ~/bootstrap; fi

extraEnvRaw:
  - name: DB_HOST
    value: "10.0.0.12"
  - name: DB_PORT
    value: "5432"
  - name: DB_USER
    value: "superset"
  - name: DB_PASS
    valueFrom:
      secretKeyRef:
        name: superset-pg-secret
        key: password
  - name: SUPERSET_SECRET_KEY
    valueFrom:
      secretKeyRef:
        name: superset-secrets
        key: SECRET_KEY
  - name: POCKETID_CLIENT_ID
    valueFrom:
      secretKeyRef:
        name: superset-secrets
        key: POCKETID_CLIENT_ID
  - name: POCKETID_CLIENT_SECRET
    valueFrom:
      secretKeyRef:
        name: superset-secrets
        key: POCKETID_CLIENT_SECRET
